
import thenFs from 'then-fs';


thenFs.readFile().then(
    result => { console.log('result') },
    error => { console.log('error') }
)
thenFs.readFile().then(
    result => { console.log('result') },
    error => { console.log('error') }
)
thenFs.readFile().then(
    result => { console.log('result') },
    error => { console.log('error') }
)
// 上述的代码无法保证文件的读取顺序，需要进一步改进

/* 
    基于 then-fs 读取文件内容
    由于node.js官方提供的fs模块仅仅支持以回调函数的方式读取文件，不支持promise
    所以我们要用 then-fs这个第三方包，从而支持promise


    可以 在 npm 的官网搜索，查找这个包, 执行对应的命令把这个包下载到 node_modules 中 */


/*
    通过多个回调函数的互相嵌套，保证多个异步任务的执行顺序，就需要把异步任务的回调函数嵌套,
    就是上一个异步任务的回调函数需要依赖下一个异步任务的回调函数，就需要把他们嵌套在一起，但是这样如果嵌套的层次多了，就容易形成回调地狱，可读性变差，代码冗余，耦合性变强
    这样就会造成回调地狱，代码冗余，可读性变差，耦合性变强
    多层回调函数的相互嵌套，就形成了回调地狱
    代码耦合性太强
    大量冗余的代码互相嵌套，代码的可读性变差

    es6中新增了promise 解决回调地狱的问题(回调函数的嵌套,代码可读性变差的问题)


    异步效果的代码：定时任务，ajax，事件函数
    多次异步调用的依赖分析:
     多次异步调用顺序不确定，异步调用结果如果存在依赖需要嵌套



    */


/*
    1.异步编程的认识:
        1.异步效果的代码：定时任务，ajax，事件函数
        2.多个异步任务顺序执行:  如果说有多个异步任务，他们的执行顺序是不确定的，要想实现这些异步任务的执行顺序，就需要进行异步任务中回调函数的嵌套

        多次异步调用的依赖分析:
        多次异步调用顺序不确定，异步调用结果如果存在依赖需要嵌套
 
    2.异步任务的回调嵌套缺点:
      通过多个回调函数的互相嵌套，保证多个异步任务的执行顺序，就需要把异步任务的回调函数嵌套,
      就是上一个异步任务的回调函数需要依赖下一个异步任务的回调函数，就需要把他们嵌套在一起，但是这样如果嵌套的层次多了，就容易形成回调地狱，可读性变差，代码冗余，耦合性变强
 

 
 
    3.promise 是异步编程的一种解决方案，可以实现异步。还可以解决回调地狱的问题

        使用promise的好处:
        1.可以避免多层异步调用嵌套问题(回调地狱)
        2.promise 对象提供了简洁的api，使得控制异步操作更加的容易

        3.resolve 和 reject 两个参数用于处理成功和失败的两种情况，并通过p.then()获取处理结果

        // 传入一个构造函数，构造参数是resolve 和 reject
        var p=new Promise(function (resolve,reject) {
        
            // 1.成功时调用
                resolve();

            // 2.失败时调用
                reject();
        })


*/


